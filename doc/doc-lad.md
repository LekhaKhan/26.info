# Оброблення рядків, масивів. Бібліотека lodash

## Рядки
Рядок у JS – це послідовність символів що представлені у Unicode. Символи включають в себе цифри, літери, знаки пунктуації, спеціальні символи та пропуски.

В JavaScript будь-які текстові дані є рядками. Не існує окремого типу «символ», який є в ряді інших мов. Внутрішній формат для рядків - завжди UTF-16, незалежно від кодування сторінки.
В JavaScript є різні типи лапок.

Рядок можна створити за допомогою одинарних, подвійних або зворотних лапок:

```js
let single = 'single-quoted';
let double = "double-quoted";

let backticks = `backticks`;
```

Одинарні та подвійні лапки працюють, по суті, однаково, а якщо використовувати зворотні лапки, то в такий рядок ми зможемо вставляти довільні вирази, обернувши їх в `$ {...}`:

```js
function sum(a, b) {
  return a + b;
}

alert(`1 + 2 = ${sum(1, 2)}`); // 1 + 2 = 3
```

Багаторядкові рядки також можна створювати за допомогою одинарних і подвійних лапок, використовуючи так званий «символ перекладу рядка», який записується як `\n`:

```js
let guestList = "Guests:\n * John\n * Pete\n * Mary";

alert(guestList); // список гостей, состоящий из нескольких строк
```

Зокрема, ці два рядки еквівалентні, просто записані по-різному:

```js
// перевод строки добавлен с помощью символа перевода строки
let str1 = "Hello\nWorld";

// многострочная строка, созданная с использованием обратных кавычек
let str2 = `Hello
World`;

alert(str1 == str2); // true
```

Є й інші, рідше використовуються спецсимволи. Ось список:

Спецсимвол | Опис
--- | ---
\n	| Перенос рядка 
\r	| Повернення каретки: самостійно не використовується. У текстових файлах Windows для перекладу рядка використовується комбінація символів \ r \ n.
\’   \” | Лапки
\\\	| Зворотній слеш
\t	| Знак табуляції
\b, \f, \v	| Backspace, Form Feed і Vertical Tab - залишені для забезпечення сумісності, зараз не використовуються.
\xXX | Символ з шістнадцятковим Юнікодним кодом XX, наприклад, '\ x7A' - те ж саме, що 'z'.
\uXXXX	| Символ в кодуванні UTF-16 з шістнадцятковим кодом XXXX, наприклад, \ u00A9 - Юнікодним уявлення знаку копірайту, ©. Код повинен складатися рівно з 4 шістнадцяткових цифр.
\u{X…XXXX}(від 1 до 6 шістнадцятирічних цифр)	| Символ в кодуванні UTF-32 з шістнадцятковим кодом від U + 0000 до U + 10FFFF. Деякі рідкісні символи кодуються двома 16-бітними словами і займають 4 байти. Так можна вставляти символи з довгим кодом.

***

Всі спецсимволи починаються з зворотного слеша, \ - так званого «символу екранування».
Отримати символ, який займає позицію pos, можна за допомогою квадратних дужок: [pos]. Перший символ займає нульову позицію:

```js
let str = `Hello`;

// получаем первый символ
alert( str[0] ); // H
alert( str.charAt(0) ); // H

// получаем последний символ
alert( str[str.length - 1] ); // o
```

Вміст рядка в JavaScript не можна змінити. Не можна взяти символ посередині і замінити його. Як тільки рядок створено - він такий назавжди.

## Масиви
Існує два варіанти синтаксису для створення порожнього масиву:

```js
let arr = new Array();
let arr = [];
```

Практично завжди використовується другий варіант синтаксису. У дужках ми можемо вказати початкові значення елементів:

```js
let fruits = ["Яблоко", "Апельсин", "Слива"];
```

Елементи масиву нумеруються з нуля.
Існує декілька методів масивів:
*	arr.push(...items) – додає елементи в кінець,
*	arr.pop() – витягує елемент з кінця,
*	arr.shift() – витягує елемент з початку,
*	arr.unshift(...items) – додає елементи в початок.
*	arr.splice(index[, deleteCount, elem1, ..., elemN]) – видалення елементів
*	arr.length – довжина масиву
тощо.

## Бібліотека Lodash

**Lodash** - це бібліотека JavaScript з величезною кількістю функцій для роботи з різними структурами даних, яка допомагає програмістам писати більш компактний і простий в обслуговуванні JavaScript код.

Його можна розбити на кілька основних напрямків:
* Utilities – для спрощення загальних завдань програмування, таких як визначення типу, а також спрощення математичних операцій;
* Function – спрощення зв'язування, декорування, стримування, дросселирование, debouncing, currying і зміна покажчика;
* String – функції перетворення для виконання основних операцій з рядками, такі як обрізка, перетворення в верхній регістр, випадок верблюда і т.д;
* Array – створення, розбиття, об'єднання, зміну і стиснення;
* Collection – ітерація, сортування, фільтрація, розщеплення і будівництво;
* Object – доступ, розширення, злиття, дефолти і перетворення;
* Seq – caching, упаковка, фільтрація і тестування.

Почати користуватися Lodash дуже просто, бібліотека доступна для установки з CDN без використання складальників, доступна на npm, є підтримка TypeScript.
З випуском ES6 і більш пізніми версіями JavaScript з'явилося безліч методів, які розширюють функціональність мови. Наприклад, з'явилися нові методи масивів і рядків, а також такі корисні оператори, як spread і rest.
Однак Lodash, залишається актуальним, оскільки містить безліч корисних методів, все ще не доступних в JavaScript з коробки.

Декілька з них:

### _.times

Метод times дозволяє викликати функцію кілька разів, поміщає результат виклику кожної функції в масив і повертає масив.
Метод приймає два аргументи: кількість викликів функції і саму функцію для виклику. Наприклад:

```js
import * as _ from "lodash";const getRandomInteger = () => Math.round(Math.random() * 100);
let result = _.times(5, getRandomInteger);
console.log(result);
```

Результат:

```js
[16, 83, 35, 87, 41]
```

### _.debounce

Метод debounce використовується для того, щоб відкласти виклик функції на певний час. В JavaScript не існує простого способу зробити це.
Метод корисний для обробки подій, якщо ми хочемо почекати, поки виконається щось, а потім викликати функцію. Наприклад, якщо ви шукаєте введення клавіатури debounce чекатиме, поки користувач закінчить введення, перш ніж викликати API, видаляючи непотрібні звернення до сервера.

При числoвому вводі:

```js
import * as _ from "lodash";
const checkPositiveNumber = e => {
  console.log(+e.target.value > 0);
};
const numInput = document.querySelector("input[type=number]");
numInput.addEventListener("input", _.debounce(checkPositiveNumber, 600));
```

Він містить функцію checkPositiveNumber, яка перевіряє, чи є введене значення позитивним. Потім використовуємо метод debounce, який приймає в якості значень функцію і затримку виклику в мілісекундах.
Функція, яку повертає debouce, має ті ж параметри, що і початкова функція, за винятком того, що її виклик затримується на зазначений час.

### _.get

Метод get дозволяє нам безпечним способом отримати доступ до властивостей об'єкта. Навіть якщо шляху до властивостей не існує, метод поверне undefined або значення за замовчуванням замість збою програми.
Наприклад:

```js
const obj = {
 foo: {
  bar: { baz: { a: 3 } },
  foo: { b: 2 },
  baz: [1, 2, 3]
 }
};
```

Перший аргумент - це об'єкт, до значення властивості якого ми хочемо отримати доступ. Другий - це шлях до властивості. Останній аргумент - значення за замовчуванням. Отримаємо 3 в якості result.
У той же час, якщо шлях не існує або undefined, ми отримаємо undefined або значення за замовчуванням. Наприклад, якщо у нас є:

```js
const result = _.get(obj, "foo.bar.a", 1);
```

Ми отримаємо 1 в result. Якщо ми не поставимо значення за замовчуванням:

```js
const result = _.get(obj, "foo.bar.a");
```

Отримаємо undefined. Не існує способу безпечно отримати значення глибоко вкладеного властивості, поки оператор опціональною послідовності не стане основним.

### _.set

Метод set потрібен, щоб задати значення властивості об'єкта. Наприклад, дано той же об'єкт, що ми використовували вище.
Задати значення властивості можна, написавши:

```js
_.set(obj, "foo.bar.a", 1);
```

Об'єкт obj змінений. Як бачимо, метод може задавати значення для властивостей, які до цього не існували. У вихідного об'єкта не було foo.bar.a, він автоматично додався після того, як було встановлено значення 1.
Отримуємо:

```js
{
 "foo": {
  "bar": {
   "baz": {
    "a": 3
   },
   "a": 1
  },
  "foo": {
   "b": 2
  },
  "baz": [
   1,
   2,
   3
  ]
 }
}
```

Це працює, навіть якщо вкладений об'єкт не існує.

### _.deburr

Щоб видалити надрядкові знаки у символів рядка, використовуємо метод deburr. Він приймає рядок і повертає нову, де символи з наголосами замінені на символи без них.
Наприклад, рядок "S'il vous plaît":

```js
const result = _.deburr("S'il vous plaît");
```

Перетворюється в "S'il vous plait". У 'i' більше немає надрядкового знаку.

### _.keyBy

Метод keyBy приймає масив і ім'я властивості і повертає об'єкт зі значенням властивості в якості ключів об'єкта. Наприклад, у нас є наступний масив:

```js
const people = [
   {Name: "Joe", age: 20},
   {Name: "Jane", age: 18},
   {Name: "Mary", age: 20}
];
```

Використовуємо keyBy:

```js
const results = _.keyBy (people, "name");
```

Тоді results буде наступним:

```js
{
   "Joe": {
     "Name": "Joe",
     "Age": 20
   },
   "Jane": {
     "Name": "Jane",
     "Age": 18
   },
   "Mary": {
     "Name": "Mary",
     "Age": 20
   }
}
```

Потім отримаємо об'єкт з ім'ям 'Joe', написавши:

```js
results ['Joe']
```

У чистому JavaScript немає простого способу зробити це без написання кількох рядків коду.

### _.uniq(array)

Створює без дублікатів версію масиву, використовуючи SameValueZero для порівняння рівності, в якій зберігається лише перша поява кожного елемента. Порядок значень результатів визначається порядком їх виникнення в масиві.

```js
_.uniq([2, 1, 2, 3, 1]);
```

Результат:

```js
[2, 1, 3]
```

Також існує \_.uniqBy(array, [iteratee=_.identity]) , який схожий на _.uniq, за винятком того, що він приймає ітерацію, яка викликається для кожного елемента масиву, щоб генерувати критерій, за яким обчислюється унікальність. Порядок значень результатів визначається порядком їх виникнення в масиві. Ітератор викликається одним аргументом.

### _.zip([arrays])

Створює масив згрупованих елементів, перший з яких містить перші елементи заданих масивів, другий з яких містить другі елементи даних масивів тощо.

```js
_.zip(['a', 'b'], [1, 2], [true, false]);
```

Результат:

```js
[['a', 1, true], ['b', 2, false]]
```

### Висновок
У Lodash є багато корисних функцій, простих аналогів яким немає в чистому JavaScript.